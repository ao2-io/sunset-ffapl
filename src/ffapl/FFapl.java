/* Generated By:JavaCC: Do not edit this line. FFapl.java */
package ffapl;
import java.io.*;
import ffapl.lib.interfaces.*;
import ffapl.java.interfaces.*;
import ffapl.lib.*;
import ffapl.exception.*;
import ffapl.ast.nodes.*;
import ffapl.ast.*;
import ffapl.visitor.*;
import ffapl.types.*;
import ffapl.java.logging.*;
import ffapl.java.exception.*;

/**
 * @author Alexander Ortner
 * @version 1.0
 *
 */
public class FFapl extends Thread implements FFaplASTreeConstants, FFaplConstants {
  private static String _programName = "";
  private FFaplLogger _logger;
  private FFaplSymbolTypeCheckingVisitor _symbolVisit;
  private FFaplJavaInterpreterVisitor _javaInterpreter;
  private static FFaplSymbolTable _symbolTable;
  private ASTProgram _root;
  public static boolean _interrupted;

  /**
   * @param stream
   * @param logger 
   * @param language
   */
  public FFapl(Reader reader, FFaplLogger logger, String language)
  {
                this(reader);
                _logger = logger;
                _interrupted = false;

  }


  /**
  * Start to parse and interpret the code
  */
  public void run()
  {
        try
        {
                        _root = Program();
                        //generate SymbolTable
                _symbolTable = new FFaplSymbolTable();
                //Symbol and Type checking
                _symbolVisit = new FFaplSymbolTypeCheckingVisitor(_symbolTable, _logger, this);
                _symbolVisit.visit(_root, null);
                //interpret        	
                _javaInterpreter = new FFaplJavaInterpreterVisitor(_symbolTable, _logger, this);
                _javaInterpreter.visit(_root, null);
        }catch(ParseException pe){
                _logger.log(ILevel.ERROR,
                                        CompilerMessage.getError((ICompilerError) pe, _programName),
                                        pe.errorLine(),
                                        pe.errorColumn());
        }catch(TokenMgrError te){
                _logger.log(ILevel.ERROR,
                                        CompilerMessage.getError((ICompilerError) te, _programName),
                                        te.errorLine(),
                                        te.errorColumn());
        }catch(FFaplAlgebraicException e){
                        _logger.log(ILevel.ERROR, CompilerMessage.getError((ICompilerError) e, _programName),
                                    e.errorLine(),
                                    e.errorColumn());
                }catch(FFaplException ffe){
                _logger.log(ILevel.ERROR, CompilerMessage.getError((ICompilerError) ffe, _programName),
                            ffe.errorLine(),
                            ffe.errorColumn());
        }/*catch(Exception general)
    	{
    	   Object[] arguments = {FFaplException.getCustomStackTrace(general)};
			_logger.log(ILevel.ERROR, (new FFaplException(arguments, ICompilerError.INTERNAL)).getErrorMessage());
    	}*/
  }

/* ----- ENDCOMMENTS ------ */





/* Operations */
  final public ASTRelOp RelOp() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2;
  FFaplNodeChoice t3;
  int pos = 0;
  int amount = 4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOWER_EQUAL:
      t1 = jj_consume_token(LOWER_EQUAL);
              pos = 0;
      break;
    case GREATER_EQUAL:
      t1 = jj_consume_token(GREATER_EQUAL);
          pos = 1;
      break;
    case GREATER:
      t1 = jj_consume_token(GREATER);
              pos = 2;
      break;
    case LOWER:
      t1 = jj_consume_token(LOWER);
             pos = 3;
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t2 = new FFaplNodeToken(t1);
        t3 = new FFaplNodeChoice(t2, pos, amount);
    {if (true) return new ASTRelOp(FFT_RELOP, t3);}
    throw new Error("Missing return statement in function");
  }

  final public ASTEqualOp EqualOp() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2;
  FFaplNodeChoice t3;
  int pos = 0;
  int amount = 2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      t1 = jj_consume_token(EQUAL);
              pos = 0;
      break;
    case NOT_EQUAL:
      t1 = jj_consume_token(NOT_EQUAL);
              pos = 1;
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t2 = new FFaplNodeToken(t1);
        t3 = new FFaplNodeChoice(t2, pos, amount);
    {if (true) return new ASTEqualOp(FFT_EQUALOP, t3);}
    throw new Error("Missing return statement in function");
  }

  final public ASTAddOp AddOp() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2;
  FFaplNodeChoice t3;
  int pos = 0;
  int amount = 2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      t1 = jj_consume_token(PLUS);
              pos = 0;
      break;
    case MINUS:
      t1 = jj_consume_token(MINUS);
              pos = 1;
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t2 = new FFaplNodeToken(t1);
        t3 = new FFaplNodeChoice(t2, pos, amount);
    {if (true) return new ASTAddOp(FFT_ADDOP, t3);}
    throw new Error("Missing return statement in function");
  }

  final public ASTMulOp MulOp() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2;
  FFaplNodeChoice t3;
  int pos = 0;
  int amount = 3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MULTIPLY:
      t1 = jj_consume_token(MULTIPLY);
              pos = 0;
      break;
    case DIVIDE:
      t1 = jj_consume_token(DIVIDE);
              pos = 1;
      break;
    case MODULO:
      t1 = jj_consume_token(MODULO);
              pos = 2;
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t2 = new FFaplNodeToken(t1);
        t3 = new FFaplNodeChoice(t2, pos, amount);
    {if (true) return new ASTMulOp(FFT_MULOP, t3);}
    throw new Error("Missing return statement in function");
  }

  final public ASTRandom Random() throws ParseException, FFaplException {
 Token t1;
 FFaplNodeOpt t2;
 FFaplNodeToken t3;
 ASTExpr t4;
 FFaplNodeSequence t5;
 FFaplNodeOpt t6;
 FFaplNodeSequence t7;
    t1 = jj_consume_token(RANDOM);
    t3 = new FFaplNodeToken(t1);
    t2 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BRACE_LEFT:
                  t5 = new FFaplNodeSequence();
      t1 = jj_consume_token(BRACE_LEFT);
                          t5.addNode(new FFaplNodeToken(t1));
      t4 = Expr();
                          t5.addNode(t4);
                          t6 = new FFaplNodeOpt();
                          t5.addNode(t6);//adds Optional Node to Sequence

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
                      t7 = new FFaplNodeSequence();
        t1 = jj_consume_token(COLON);
                                  t7.addNode(new FFaplNodeToken(t1));
        t4 = Expr();
                          t7.addNode(t4);
                          t6.addNode(t7);//adds sequence to optional node

        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      t1 = jj_consume_token(BRACE_RIGHT);
          t5.addNode(new FFaplNodeToken(t1));
          t2.addNode(t5); //adds Sequence to Optional Node

      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    {if (true) return new ASTRandom(FFT_RANDOM, t3, t2);}
    throw new Error("Missing return statement in function");
  }

  final public ASTRandomGenerator RandomGenerator() throws ParseException, FFaplException {
  Token t1;
  ASTExpr t2;
  FFaplNodeToken t3, t4, t5;
  FFaplNodeOpt t6;
  FFaplNodeSequence t7;
  ASTExpr t8;
    t1 = jj_consume_token(RANDOMGENERATOR);
                  t3 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(BRACE_LEFT);
                  t4 = new FFaplNodeToken(t1);
    t2 = Expr();
                  t6 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
                                  t7 = new FFaplNodeSequence();
      t1 = jj_consume_token(COLON);
                  t7.addNode(new FFaplNodeToken(t1));
      t8 = Expr();
                  t7.addNode(t8);
                  t6.addNode(t7);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    t1 = jj_consume_token(BRACE_RIGHT);
          t5 = new FFaplNodeToken(t1);
          {if (true) return new ASTRandomGenerator(FFT_RANDOMGENERATOR, t3, t4, t2, t6, t5);}
    throw new Error("Missing return statement in function");
  }

  final public ASTLiteral Literal() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeChoice t2;
  FFaplNodeToken t3;
  ASTRandom t4;
  ASTPolynomial t5;
  int amount = 6;
  FFaplNodeType t6;
        t6 = new FFaplNodeType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      t1 = jj_consume_token(TRUE);
             t6.setType(new FFaplBoolean(true));
             t6.addNode(new FFaplNodeToken(t1));
             t2 = new FFaplNodeChoice(t6, 0, amount);
      break;
    case FALSE:
      t1 = jj_consume_token(FALSE);
             t6.setType(new FFaplBoolean(false));
             t6.addNode(new FFaplNodeToken(t1));
             t2 = new FFaplNodeChoice(t6, 1, amount);
      break;
    case RANDOM:
      t4 = Random();
             t6.setType(new FFaplRandom());
             t6.addNode(t4);
             t2 = new FFaplNodeChoice(t6, 2, amount);
      break;
    case NUMBER:
      t1 = jj_consume_token(NUMBER);
             t6.setType(new FFaplInteger(t1.image));
             t6.addNode(new FFaplNodeToken(t1));
             t2 = new FFaplNodeChoice(t6, 3, amount);
      break;
    case SQUARED_BRACE_LEFT:
      t5 = Polynomial();
             t6.setType(new FFaplPolynomial());
             t6.addNode(t5);
             t2 = new FFaplNodeChoice(t6, 4, amount);
      break;
    case STRING:
      t1 = jj_consume_token(STRING);
                                t6.setType(new FFaplString(t1.image));
                        t6.addNode(new FFaplNodeToken(t1));
                        t2 = new FFaplNodeChoice(t6, 5, amount);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ASTLiteral(FFT_LITERAL, t2);}
    throw new Error("Missing return statement in function");
  }

  final public ASTSelector Selector() throws ParseException, FFaplException {
        Token t1;
        FFaplNodeChoice t2;
        FFaplNodeToken t3;
        FFaplNodeSequence t4;
        ASTExpr t5;
        ASTSelector t6;
        FFaplNodeOpt t7;
        int amount = 2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQUARED_BRACE_LEFT:
              t4 = new FFaplNodeSequence();
      //start sequence
              t1 = jj_consume_token(SQUARED_BRACE_LEFT);
             t4.addNode(new FFaplNodeToken(t1));
      t5 = Expr();
             t4.addNode(t5);
      t1 = jj_consume_token(SQUARED_BRACE_RIGHT);
             t4.addNode(new FFaplNodeToken(t1));
             t7 = new FFaplNodeOpt();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQUARED_BRACE_LEFT:
      case DOT:
        //Optional Node
                        t6 = Selector();
                  t7.addNode(t6);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
                  t4.addNode(t7);
                  t2 = new FFaplNodeChoice(t4, 0, amount);
      break;
    case DOT:
                t4 = new FFaplNodeSequence();
      //start sequence
              t1 = jj_consume_token(DOT);
             t4.addNode(new FFaplNodeToken(t1));
      t1 = jj_consume_token(IDENT);
             t4.addNode(new FFaplNodeToken(t1));
             t7 = new FFaplNodeOpt();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQUARED_BRACE_LEFT:
      case DOT:
        //Optional
                        t6 = Selector();
                  t7.addNode(t6);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
                  t4.addNode(t7);
                  t2 = new FFaplNodeChoice(t4, 1, amount);//adds sequence to choice

      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ASTSelector(FFT_SELECTOR, t2);}
    throw new Error("Missing return statement in function");
  }

  final public ASTArrayLen ArrayLen() throws ParseException, FFaplException {
        Token t1;
        FFaplNodeOpt t2;
        ASTSelector t3;
        FFaplNodeToken t4, t5;
    t1 = jj_consume_token(HASH_KEY);
                  t4 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(IDENT);
                  t5 = new FFaplNodeToken(t1);
                  t2 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQUARED_BRACE_LEFT:
    case DOT:
      //Optional
                      t3 = Selector();
                          t2.addNode(t3);
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
          {if (true) return new ASTArrayLen(FFT_ARRAYLEN, t4, t5, t2);}
    throw new Error("Missing return statement in function");
  }

  final public ASTPrimaryExpr PrimaryExpr() throws ParseException, FFaplException {
        Token t1;
        FFaplNodeChoice t2;
        FFaplNodeSequence t3;
        ASTLiteral t4;
        ASTExpr t5;
        ASTProcFuncCall t6;
        ASTSelector t7;
        ASTArrayLen t8;
        FFaplNodeOpt t9;
        ASTArgumentList t10;
        int amount = 6;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQUARED_BRACE_LEFT:
    case TRUE:
    case FALSE:
    case RANDOM:
    case NUMBER:
    case STRING:
      t4 = Literal();
                  t2 = new FFaplNodeChoice(t4, 0, amount);
      break;
    case BRACE_LEFT:
                          t3 = new FFaplNodeSequence();
      t1 = jj_consume_token(BRACE_LEFT);
                          t3.addNode(new FFaplNodeToken(t1));
      t5 = Expr();
                          t3.addNode(t5);
      t1 = jj_consume_token(BRACE_RIGHT);
                          t3.addNode(new FFaplNodeToken(t1));
                          t2 = new FFaplNodeChoice(t3, 1, amount);
      break;
    default:
      jj_la1[13] = jj_gen;
      if (jj_2_1(2)) {
        t6 = ProcFuncCall();
                                t2 = new FFaplNodeChoice(t6, 2, amount);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
                          t3 = new FFaplNodeSequence();
          t1 = jj_consume_token(IDENT);
                          t3.addNode(new FFaplNodeToken(t1));
                          t9 = new FFaplNodeOpt();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SQUARED_BRACE_LEFT:
          case DOT:
            t7 = Selector();
                                        t9.addNode(t7);
            break;
          default:
            jj_la1[12] = jj_gen;
            ;
          }
                  t3.addNode(t9);
                  t2 = new FFaplNodeChoice(t3, 3, amount);
          break;
        case HASH_KEY:
          t8 = ArrayLen();
                  t2 = new FFaplNodeChoice(t8, 4, amount);
          break;
        case CURLY_BRACE_LEFT:
                          t3 = new FFaplNodeSequence();
          t1 = jj_consume_token(CURLY_BRACE_LEFT);
                          t3.addNode(new FFaplNodeToken(t1));
          t10 = ArgumentList();
                          t3.addNode(t10);
          t1 = jj_consume_token(CURLY_BRACE_RIGHT);
                          t3.addNode(new FFaplNodeToken(t1));
                          t2 = new FFaplNodeChoice(t3, 5, amount);
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    {if (true) return new ASTPrimaryExpr(FFT_PRIMARYEXPR, t2);}
    throw new Error("Missing return statement in function");
  }

  final public ASTUnaryExpr UnaryExpr() throws ParseException, FFaplException {
  Token t5;
  ASTAddOp t1;
  ASTPrimaryExpr t2;
  FFaplNodeOpt t3;
  FFaplNodeChoice t4;
  int amount = 2;
          t3 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        t1 = AddOp();
                  t4 = new FFaplNodeChoice(t1, 0, amount);
        break;
      case NOT:
        //or
                        t5 = jj_consume_token(NOT);
                  t4 = new FFaplNodeChoice(new FFaplNodeToken(t5), 1, amount);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          t3.addNode(t4);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    t2 = PrimaryExpr();
    {if (true) return new ASTUnaryExpr(FFT_UNARYEXPR, t3, t2);}
    throw new Error("Missing return statement in function");
  }

  final public ASTPowExpr PowExpr() throws ParseException, FFaplException {
  Token t1;
  ASTUnaryExpr t2, t3;
  FFaplNodeListOpt t4;
  FFaplNodeSequence t5;
    t2 = UnaryExpr();
          t4 = new FFaplNodeListOpt();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POWER:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_1;
      }
              t5 = new FFaplNodeSequence();
      t1 = jj_consume_token(POWER);
          t5.addNode(new FFaplNodeToken(t1));
      t3 = UnaryExpr();
              t5.addNode(t3);
              t4.addNode(t5);
    }
     {if (true) return new ASTPowExpr(FFT_POWEXPR, t2, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTMulExpr MulExpr() throws ParseException, FFaplException {
  ASTPowExpr t1, t2;
  ASTMulOp t3;
  FFaplNodeListOpt t4;
  FFaplNodeSequence t5;
    t1 = PowExpr();
    t4 = new FFaplNodeListOpt();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case DIVIDE:
      case MODULO:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_2;
      }
          t5 = new FFaplNodeSequence();
      t3 = MulOp();
          t5.addNode(t3);
      t2 = PowExpr();
          t5.addNode(t2);
          t4.addNode(t5);
    }
    {if (true) return new ASTMulExpr(FFT_MULEXPR, t1, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTAddExpr AddExpr() throws ParseException, FFaplException {
  ASTMulExpr t1;
  FFaplNodeListOpt t2 = new FFaplNodeListOpt();
  FFaplNodeSequence t3 = null;
  ASTAddOp t4;
  ASTMulExpr t5;
    t1 = MulExpr();
    label_3:
    while (true) {
      if (jj_2_2(2)) {
        ;
      } else {
        break label_3;
      }
      t3 = new FFaplNodeSequence();
      t4 = AddOp();
      t5 = MulExpr();
      t3.addNode(t4);//adds node to sequence
      t3.addNode(t5);//adds node to sequence
      t2.addNode(t3);//adds Sequence to Optional List

    }
    {if (true) return new ASTAddExpr(FFT_ADDEXPR, t1, t2);}
    throw new Error("Missing return statement in function");
  }

  final public ASTRelExpr RelExpr() throws ParseException, FFaplException {
  ASTAddExpr t1, t2;
  ASTRelOp t3;
  FFaplNodeOpt t4;
  FFaplNodeSequence t5;
    t1 = AddExpr();
            t4 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOWER:
    case GREATER:
    case LOWER_EQUAL:
    case GREATER_EQUAL:
                  t5 = new FFaplNodeSequence();
      t3 = RelOp();
                  t5.addNode(t3);
      t2 = AddExpr();
                  t5.addNode(t2);
                  t4.addNode(t5);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    {if (true) return new ASTRelExpr(FFT_RELEXPR, t1, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTEqualExpr EqualExpr() throws ParseException, FFaplException {
  ASTRelExpr t1, t2;
  ASTEqualOp t3;
  FFaplNodeOpt t4;
  FFaplNodeSequence t5;
    t1 = RelExpr();
            t4 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
    case NOT_EQUAL:
            t5 = new FFaplNodeSequence();
      t3 = EqualOp();
                  t5.addNode(t3);
      t2 = RelExpr();
                  t5.addNode(t2);
                  t4.addNode(t5);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    {if (true) return new ASTEqualExpr(FFT_EQUALEXPR, t1, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTCondAndExpr CondAndExpr() throws ParseException, FFaplException {
  ASTEqualExpr t1, t2;
  Token t3;
  FFaplNodeListOpt t4;
  FFaplNodeSequence t5;
    t1 = EqualExpr();
            t4 = new FFaplNodeListOpt();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_4;
      }
            t5 = new FFaplNodeSequence();
      t3 = jj_consume_token(AND);
                  t5.addNode(new FFaplNodeToken(t3));
      t2 = EqualExpr();
                  t5.addNode(t2);
                  t4.addNode(t5);
    }
    {if (true) return new ASTCondAndExpr(FFT_CONDANDEXPR, t1, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTCreationExpr CreationExpr() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2;
  ASTArrayType t3;
  FFaplNodeList t4;
  FFaplNodeSequence t5;
  ASTExpr t6;
  int amount = 2;
    t1 = jj_consume_token(NEW);
          t2 = new FFaplNodeToken(t1);
    t3 = ArrayType();
            t4 = new FFaplNodeList();
    label_5:
    while (true) {
            t5 = new FFaplNodeSequence();
      t1 = jj_consume_token(SQUARED_BRACE_LEFT);
                  t5.addNode(new FFaplNodeToken(t1));
      t6 = Expr();
                  t5.addNode(t6);
      t1 = jj_consume_token(SQUARED_BRACE_RIGHT);
                  t5.addNode(new FFaplNodeToken(t1));
                  t4.addNode(t5);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQUARED_BRACE_LEFT:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_5;
      }
    }
    {if (true) return new ASTCreationExpr (FFT_CREATIONEXPR, t2, t3, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTExprComplexAType ExprComplexAType() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  ASTGF t2;
  FFaplNodeSequence t6, t11;
  FFaplNodeType t8;
  FFaplNodeOpt t10;
  ASTExpr t7;
  Token t9;
  int amount = 2;
    t8 = new FFaplNodeType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GF:
      t2 = GF();
                          t8.setType(new FFaplGaloisField());
                          t8.addNode(t2);
                          t1 = new FFaplNodeChoice(t8, 0, amount);
      break;
    case Z:
                              t6 = new FFaplNodeSequence();
      t9 = jj_consume_token(Z);
                            t6.addNode(new FFaplNodeToken(t9));
      t9 = jj_consume_token(BRACE_LEFT);
                                  t6.addNode(new FFaplNodeToken(t9));
      t7 = Expr();
                                  t6.addNode(t7);
      t9 = jj_consume_token(BRACE_RIGHT);
                                  t6.addNode(new FFaplNodeToken(t9));
                                  t8.setType(new FFaplResidueClass());
                                  t10 = new FFaplNodeOpt();
      if (jj_2_3(2)) {
                                  t11 = new FFaplNodeSequence();
        t9 = jj_consume_token(SQUARED_BRACE_LEFT);
                                  t11.addNode(new FFaplNodeToken(t9));
        t9 = jj_consume_token(IDENT);
                                  t11.addNode(new FFaplNodeToken(t9));
        t9 = jj_consume_token(SQUARED_BRACE_RIGHT);
                                  t11.addNode(new FFaplNodeToken(t9));
                                  t10.addNode(t11);
                                  t8.setType(new FFaplPolynomialResidue());
      } else {
        ;
      }
                                  t6.addNode(t10);
                                  t8.addNode(t6);
                                  t1 = new FFaplNodeChoice(t8, 1, amount);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ASTExprComplexAType(FFT_EXPRCOMPLEXATYPE, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTExprRandomGType ExprRandomGType() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  ASTPsRandomGenerator t4;
  ASTRandomGenerator t5;
  FFaplNodeType t8;
  int amount = 2;
    t8 = new FFaplNodeType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PSEUDORANDOMGENERATOR:
      t4 = PsRandomGenerator();
                          t8.setType(new FFaplPsRandomGenerator());
                          t8.addNode(t4);
                          t1 = new FFaplNodeChoice(t8, 0, amount);
      break;
    case RANDOMGENERATOR:
      t5 = RandomGenerator();
                          t8.setType(new FFaplRandomGenerator());
                          t8.addNode(t5);
                          t1 = new FFaplNodeChoice(t8, 1, amount);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ASTExprRandomGType(FFT_EXPRRANDOMGTYPE, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTExpr Expr() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  FFaplNodeSequence t2, t3;
  FFaplNodeListOpt t4;
  ASTCondAndExpr t5, t6;
  ASTCreationExpr t7;
  Token t8;
  int amount = 2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
    case PLUS:
    case MINUS:
    case HASH_KEY:
    case SQUARED_BRACE_LEFT:
    case CURLY_BRACE_LEFT:
    case BRACE_LEFT:
    case TRUE:
    case FALSE:
    case RANDOM:
    case IDENT:
    case NUMBER:
    case STRING:
                t2 = new FFaplNodeSequence();
      t5 = CondAndExpr();
                    t2.addNode(t5);
                    t4 = new FFaplNodeListOpt();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_6;
        }
                      t3 = new FFaplNodeSequence();
        t8 = jj_consume_token(OR);
                      t3.addNode(new FFaplNodeToken(t8));
        t6 = CondAndExpr();
                      t3.addNode(t6);
                      t4.addNode(t3);
      }
            t2.addNode(t4);
            t1 = new FFaplNodeChoice(t2, 0, amount);
      break;
    case NEW:
      //or
            t7 = CreationExpr();
                t1 = new FFaplNodeChoice(t7, 1, amount);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ASTExpr(FFT_EXPR, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTArgumentList ArgumentList() throws ParseException, FFaplException {
  Token t1;
  ASTExpr t2, t3;
  FFaplNodeListOpt t4;
  FFaplNodeSequence t5;
    t2 = Expr();
            t4 = new FFaplNodeListOpt();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_7;
      }
            t5 = new FFaplNodeSequence();
      t1 = jj_consume_token(COMMA);
              t5.addNode(new FFaplNodeToken(t1));
      t3 = Expr();
                  t5.addNode(t3);
                  t4.addNode(t5);
    }
    {if (true) return new ASTArgumentList(FFT_ARGUMENTLIST, t2, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTProcFuncCall ProcFuncCall() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t3, t4;
  FFaplNodeOpt t5;
  ASTArgumentList t6;
    t1 = jj_consume_token(IDENT);
             t2 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(BRACE_LEFT);
             t3 = new FFaplNodeToken(t1);
             t5 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
    case PLUS:
    case MINUS:
    case HASH_KEY:
    case SQUARED_BRACE_LEFT:
    case CURLY_BRACE_LEFT:
    case BRACE_LEFT:
    case NEW:
    case TRUE:
    case FALSE:
    case RANDOM:
    case IDENT:
    case NUMBER:
    case STRING:
      t6 = ArgumentList();
                  t5.addNode(t6);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    t1 = jj_consume_token(BRACE_RIGHT);
             t4 = new FFaplNodeToken(t1);
    {if (true) return new ASTProcFuncCall(FFT_PROCFUNCCALL, t2, t3, t5, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTAssignment Assignment() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t3;
  FFaplNodeOpt t4;
  ASTSelector t5;
  ASTExpr t6;
    t1 = jj_consume_token(IDENT);
            t2 = new FFaplNodeToken(t1);
            t4 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQUARED_BRACE_LEFT:
    case DOT:
      t5 = Selector();
                  t4.addNode(t5);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    t1 = jj_consume_token(ASSIGN);
            t3 = new FFaplNodeToken(t1);
    t6 = Expr();
    {if (true) return new ASTAssignment(FFT_ASSIGNMENT, t2, t4, t3, t6);}
    throw new Error("Missing return statement in function");
  }

  final public ASTCondition Condition() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t4;
  ASTExpr t3;
    t1 = jj_consume_token(BRACE_LEFT);
            t2 = new FFaplNodeToken(t1);
    t3 = Expr();
    t1 = jj_consume_token(BRACE_RIGHT);
            t4 = new FFaplNodeToken(t1);
          {if (true) return new ASTCondition(FFT_CONDITION, t2, t3, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTBlock Block() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t5;
  FFaplNodeListOpt t3;
  ASTStatementList t4;
  ASTDecl t6;
    t1 = jj_consume_token(CURLY_BRACE_LEFT);
             t2 = new FFaplNodeToken(t1);
             t3 = new FFaplNodeListOpt();
    label_8:
    while (true) {
      if (jj_2_4(2)) {
        ;
      } else {
        break label_8;
      }
      t6 = Decl();
                  t3.addNode(t6);
    }
    t4 = StatementList();
    t1 = jj_consume_token(CURLY_BRACE_RIGHT);
             t5 = new FFaplNodeToken(t1);
          {if (true) return new ASTBlock(FFT_BLOCK, t2, t3, t4, t5);}
    throw new Error("Missing return statement in function");
  }

  final public ASTFuncBlock FuncBlock() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t6;
  FFaplNodeListOpt t3;
  ASTStatementList t4;
  ASTReturnStatement t5;
  ASTDecl t7;
    t1 = jj_consume_token(CURLY_BRACE_LEFT);
            t2 = new FFaplNodeToken(t1);
            t3 = new FFaplNodeListOpt();
    label_9:
    while (true) {
      if (jj_2_5(2)) {
        ;
      } else {
        break label_9;
      }
      t7 = Decl();
                  t3.addNode(t7);
    }
    t4 = StatementList();
    t5 = ReturnStatement();
    t1 = jj_consume_token(CURLY_BRACE_RIGHT);
            t6 = new FFaplNodeToken(t1);
    {if (true) return new ASTFuncBlock(FFT_FUNCBLOCK, t2, t3, t4, t5, t6);}
    throw new Error("Missing return statement in function");
  }

  final public ASTElseBlock ElseBlock() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  ASTIfStatement t2;
  ASTBlock t3;
  int amount = 2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      t2 = IfStatement();
                  t1 = new FFaplNodeChoice(t2, 0, amount);
      break;
    case CURLY_BRACE_LEFT:
      t3 = Block();
                  t1 = new FFaplNodeChoice(t3, 1, amount);
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ASTElseBlock(FFT_ELSEBLOCK, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTIfStatement IfStatement() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2;
  ASTCondition t3;
  ASTBlock t4;
  FFaplNodeOpt t5;
  FFaplNodeSequence t6;
  ASTElseBlock t7;
    t1 = jj_consume_token(IF);
            t2 = new FFaplNodeToken(t1);
    t3 = Condition();
    t4 = Block();
            t5 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
                  t6 = new FFaplNodeSequence();
      t1 = jj_consume_token(ELSE);
                  t6.addNode(new FFaplNodeToken(t1));
      t7 = ElseBlock();
                  t6.addNode(t7);
                  t5.addNode(t6);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
          {if (true) return new ASTIfStatement(FFT_IFSTATEMENT, t2, t3, t4, t5);}
    throw new Error("Missing return statement in function");
  }

  final public ASTWhileStatement WhileStatement() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2;
  ASTCondition t3;
  ASTBlock t4;
    t1 = jj_consume_token(WHILE);
            t2 = new FFaplNodeToken(t1);
    t3 = Condition();
    t4 = Block();
    {if (true) return new ASTWhileStatement(FFT_WHILESTATEMENT, t2, t3, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTForStatement ForStatement() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t3, t4, t6;
  ASTExpr t5, t7, t11;
  FFaplNodeOpt t8;
  ASTBlock t9;
  FFaplNodeSequence t10;
    t1 = jj_consume_token(FOR);
            t2 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(IDENT);
            t3 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(EQUAL_SIGN);
            t4 = new FFaplNodeToken(t1);
    t5 = Expr();
    t1 = jj_consume_token(TO);
            t6 = new FFaplNodeToken(t1);
    t7 = Expr();
            t8 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STEP:
                t10 = new FFaplNodeSequence();
      t1 = jj_consume_token(STEP);
                   t10.addNode(new FFaplNodeToken(t1));
      t11 = Expr();
                   t10.addNode(t11);
                   t8.addNode(t10);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    t9 = Block();
    {if (true) return new ASTForStatement(FFT_FORSTATEMENT, t2, t3, t4, t5, t6, t7, t8, t9);}
    throw new Error("Missing return statement in function");
  }

  final public ASTReturnStatement ReturnStatement() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t4;
  ASTExpr t3;
    t1 = jj_consume_token(RETURN);
            t2 = new FFaplNodeToken(t1);
    t3 = Expr();
    t1 = jj_consume_token(SEMICOLON);
            t4 = new FFaplNodeToken(t1);
    {if (true) return new ASTReturnStatement(FFT_RETURNSTATEMENT, t2, t3, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTBreak Break() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2;
    t1 = jj_consume_token(BREAK);
    t2 = new FFaplNodeToken(t1);
    {if (true) return new ASTBreak(FFT_BREAK, t2);}
    throw new Error("Missing return statement in function");
  }

  final public ASTStatementList StatementList() throws ParseException, FFaplException {
  FFaplNodeListOpt t1;
  FFaplNodeSequence t2;
  ASTStatement t3;
  Token t4;
  FFaplNodeChoice t5;
  ASTBlockStatement t6;
  int amount = 2;
            t1 = new FFaplNodeListOpt();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHILE:
      case IF:
      case FOR:
      case BREAK:
      case IDENT:
        ;
        break;
      default:
        jj_la1[33] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BREAK:
      case IDENT:
                             t2 = new FFaplNodeSequence();
        t3 = Statement();
                             t2.addNode(t3);
        t4 = jj_consume_token(SEMICOLON);
                             t2.addNode(new FFaplNodeToken(t4));
                                t5 = new FFaplNodeChoice(t2, 0, amount);
        break;
      case WHILE:
      case IF:
      case FOR:
        //or
                                t6 = BlockStatement();
                           t5 = new FFaplNodeChoice(t6, 1, amount);
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                   t1.addNode(t5);
    }
   {if (true) return new ASTStatementList(FFT_STATEMENTLIST, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTStatement Statement() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  ASTProcFuncCall t5;
  ASTAssignment t6;
  ASTBreak t7;
  int amount = 3;
    if (jj_2_6(2)) {
      t5 = ProcFuncCall();
                          t1 = new FFaplNodeChoice(t5, 0, amount);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        //or
                        t6 = Assignment();
                          t1 = new FFaplNodeChoice(t6, 1, amount);
        break;
      case BREAK:
        //or
                        t7 = Break();
                          t1 = new FFaplNodeChoice(t7, 2, amount);
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
          {if (true) return new ASTStatement(FFT_STATEMENT, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTBlockStatement BlockStatement() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  ASTIfStatement t2;
  ASTWhileStatement t3;
  ASTForStatement t4;
  int amount = 3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      t2 = IfStatement();
                          t1 = new FFaplNodeChoice(t2, 0, amount);
      break;
    case WHILE:
      //or
                      t3 = WhileStatement();
                          t1 = new FFaplNodeChoice(t3, 1, amount);
      break;
    case FOR:
      //or
                      t4 = ForStatement();
                          t1 = new FFaplNodeChoice(t4, 2, amount);
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return new ASTBlockStatement(FFT_BLOCKSTATEMENT, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTPrimitiveType PrimitiveType() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  Token t2;
  FFaplNodeOpt t3;
  FFaplNodeSequence t4, t5;
  //ASTExpr t7;
  FFaplNodeType t8;

  int amount = 3;
    t8 = new FFaplNodeType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      t2 = jj_consume_token(INTEGER);
                            t8.setType(new FFaplInteger());
                            t8.addNode(new FFaplNodeToken(t2));
                            t1 = new FFaplNodeChoice(t8, 0, amount);
      break;
    case BOOLEAN:
      //or
                        t2 = jj_consume_token(BOOLEAN);
                            t8.setType(new FFaplBoolean());
                            t8.addNode(new FFaplNodeToken(t2));
                            t1 = new FFaplNodeChoice(t8, 1, amount);
      break;
    case TSTRING:
      //or
                        t2 = jj_consume_token(TSTRING);
                            t8.setType(new FFaplString());
                            t8.addNode(new FFaplNodeToken(t2));
                            t1 = new FFaplNodeChoice(t8, 1, amount);
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new ASTPrimitiveType(FFT_PRIMITIVETYPE, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTAlgebraicType AlgebraicType() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  Token t2;
  //ASTExpr t7;
  FFaplNodeType t8;

  int amount = 2;
    t8 = new FFaplNodeType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIME:
      t2 = jj_consume_token(PRIME);
                            t8.setType(new FFaplPrime());
                            t8.addNode(new FFaplNodeToken(t2));
                            t1 = new FFaplNodeChoice(t8, 0, amount);
      break;
    case POLYNOMIAL:
      //or
                        t2 = jj_consume_token(POLYNOMIAL);
                          t8.setType(new FFaplPolynomial());
                          t8.addNode(new FFaplNodeToken(t2));
                          t1 = new FFaplNodeChoice(t8, 1, amount);
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new ASTAlgebraicType(FFT_ALGEBRAICTYPE, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTContainerType ContainerType() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  ASTRecord t2;
  //ASTExpr t7;
  FFaplNodeType t8;

  int amount = 1;
    t8 = new FFaplNodeType();
    t2 = Record();
                          t8.setType(new FFaplRecord());
                          t8.addNode(t2);
                          t1 = new FFaplNodeChoice(t8, 0, amount);
     {if (true) return new ASTContainerType(FFT_CONTAINERTYPE, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTComplexAlgebraicType ComplexAlgebraicType() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  ASTRecord t3;
  Token t5;
  FFaplNodeSequence t6, t7;
  FFaplNodeType t8;
  FFaplNodeOpt t9;
  int amount = 2;
    t8 = new FFaplNodeType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GF:
      t5 = jj_consume_token(GF);
                          t8.setType(new FFaplGaloisField());
                          t8.addNode(new FFaplNodeToken(t5));
                          t1 = new FFaplNodeChoice(t8, 0, amount);
      break;
    case Z:
                              t6 = new FFaplNodeSequence();
      t5 = jj_consume_token(Z);
                            t6.addNode(new FFaplNodeToken(t5));
      t5 = jj_consume_token(BRACE_LEFT);
                                  t6.addNode(new FFaplNodeToken(t5));
      t5 = jj_consume_token(BRACE_RIGHT);
                                  t6.addNode(new FFaplNodeToken(t5));
                                  t9 = new FFaplNodeOpt();
                                  t8.setType(new FFaplResidueClass());
      if (jj_2_7(2)) {
                                  t7 = new FFaplNodeSequence();
        t5 = jj_consume_token(SQUARED_BRACE_LEFT);
                                  t7.addNode(new FFaplNodeToken(t5));
        t5 = jj_consume_token(IDENT);
                                  t7.addNode(new FFaplNodeToken(t5));
        t5 = jj_consume_token(SQUARED_BRACE_RIGHT);
                                  t7.addNode(new FFaplNodeToken(t5));
                                  t9.addNode(t7);
                                  t8.setType(new FFaplPolynomialResidue());
      } else {
        ;
      }
                  t6.addNode(t9);
                                  t8.addNode(t6);
                                  t1 = new FFaplNodeChoice(t8, 1, amount);
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ASTComplexAlgebraicType(FFT_COMPLEXALGEBRAICTYPE, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTRandomGeneratorType RandomGeneratorType() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  ASTRecord t3;
  Token t5;
  FFaplNodeSequence t6, t7;
  FFaplNodeType t8;
  FFaplNodeOpt t9;
  int amount = 2;
    t8 = new FFaplNodeType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PSEUDORANDOMGENERATOR:
      t5 = jj_consume_token(PSEUDORANDOMGENERATOR);
                          t8.setType(new FFaplPsRandomGenerator());
                          t8.addNode(new FFaplNodeToken(t5));
                          t1 = new FFaplNodeChoice(t8, 0, amount);
      break;
    case RANDOMGENERATOR:
      t5 = jj_consume_token(RANDOMGENERATOR);
                          t8.setType(new FFaplRandomGenerator());
                          t8.addNode(new FFaplNodeToken(t5));
                          t1 = new FFaplNodeChoice(t8, 1, amount);
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ASTRandomGeneratorType(FFT_RANDOMGENERATORTYPE, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTConstType ConstType() throws ParseException, FFaplException {
  FFaplNodeChoice t3;
  ASTPrimitiveType t4;
  ASTExprComplexAType t5;
  ASTAlgebraicType t6;
  int amount = 2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Z:
    case GF:
      t5 = ExprComplexAType();
                          t3 = new FFaplNodeChoice(t5, 0, amount);
      break;
    case INTEGER:
    case BOOLEAN:
    case TSTRING:
      t4 = PrimitiveType();
                          t3 = new FFaplNodeChoice(t4, 1, amount);
      break;
    case PRIME:
    case POLYNOMIAL:
      t6 = AlgebraicType();
                          t3 = new FFaplNodeChoice(t6, 2, amount);
      break;
    default:
      jj_la1[41] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ASTConstType (FFT_CONSTTYPE, t3);}
    throw new Error("Missing return statement in function");
  }

  final public ASTArrayType ArrayType() throws ParseException, FFaplException {
  FFaplNodeChoice t3;
  ASTPrimitiveType t4;
  ASTAlgebraicType t6;
  ASTComplexAlgebraicType t7;
  int amount = 3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case BOOLEAN:
    case TSTRING:
      t4 = PrimitiveType();
                          t3 = new FFaplNodeChoice(t4, 0, amount);
      break;
    case PRIME:
    case POLYNOMIAL:
      t6 = AlgebraicType();
                          t3 = new FFaplNodeChoice(t6, 1, amount);
      break;
    case Z:
    case GF:
      t7 = ComplexAlgebraicType();
                          t3 = new FFaplNodeChoice(t7, 2, amount);
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ASTArrayType (FFT_ARRAYTYPE, t3);}
    throw new Error("Missing return statement in function");
  }

  final public ASTDeclType DeclType() throws ParseException, FFaplException {
  Token t0;
  FFaplNodeChoice t1;
  ASTPrimitiveType t2;
  FFaplNodeSequence t4, t6;
  FFaplNodeListOpt t5;
  ASTContainerType t7;
  ASTAlgebraicType t8;
  ASTExprComplexAType t9;
  ASTExprRandomGType t10;
  int amount = 5;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RANDOMGENERATOR:
    case PSEUDORANDOMGENERATOR:
      t10 = ExprRandomGType();
                          t1 = new FFaplNodeChoice(t10, 0, amount);
      break;
    case Z:
    case GF:
                    t4 = new FFaplNodeSequence();
      t9 = ExprComplexAType();
                          t4.addNode(t9);
                          t5 = new FFaplNodeListOpt();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SQUARED_BRACE_LEFT:
          ;
          break;
        default:
          jj_la1[43] = jj_gen;
          break label_11;
        }
                              t6 = new FFaplNodeSequence();
        t0 = jj_consume_token(SQUARED_BRACE_LEFT);
                                  t6.addNode(new FFaplNodeToken(t0));
        t0 = jj_consume_token(SQUARED_BRACE_RIGHT);
                                  t6.addNode(new FFaplNodeToken(t0));
                                  t5.addNode(t6);
      }
                    t4.addNode(t5);
                    t1 = new FFaplNodeChoice(t4, 1, amount);
      break;
    case INTEGER:
    case BOOLEAN:
    case TSTRING:
                    t4 = new FFaplNodeSequence();
      t2 = PrimitiveType();
                          t4.addNode(t2);
                          t5 = new FFaplNodeListOpt();
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SQUARED_BRACE_LEFT:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_12;
        }
                              t6 = new FFaplNodeSequence();
        t0 = jj_consume_token(SQUARED_BRACE_LEFT);
                                  t6.addNode(new FFaplNodeToken(t0));
        t0 = jj_consume_token(SQUARED_BRACE_RIGHT);
                                  t6.addNode(new FFaplNodeToken(t0));
                                  t5.addNode(t6);
      }
                    t4.addNode(t5);
                    t1 = new FFaplNodeChoice(t4, 2, amount);
      break;
    case PRIME:
    case POLYNOMIAL:
                    t4 = new FFaplNodeSequence();
      t8 = AlgebraicType();
                          t4.addNode(t8);
                          t5 = new FFaplNodeListOpt();
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SQUARED_BRACE_LEFT:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_13;
        }
                              t6 = new FFaplNodeSequence();
        t0 = jj_consume_token(SQUARED_BRACE_LEFT);
                                  t6.addNode(new FFaplNodeToken(t0));
        t0 = jj_consume_token(SQUARED_BRACE_RIGHT);
                                  t6.addNode(new FFaplNodeToken(t0));
                                  t5.addNode(t6);
      }
                    t4.addNode(t5);
                    t1 = new FFaplNodeChoice(t4, 3, amount);
      break;
    case RECORD:
      //or
      
                      t7 = ContainerType();
                          t1 = new FFaplNodeChoice(t7, 4, amount);
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return new ASTDeclType(FFT_DECLTYPE, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTParamType ParamType() throws ParseException, FFaplException {
  Token t0;
  FFaplNodeChoice t1;
  ASTPrimitiveType t2;
  FFaplNodeSequence t4, t6;
  FFaplNodeListOpt t5;
  ASTAlgebraicType t8;
  ASTComplexAlgebraicType t9;
  ASTRandomGeneratorType t10;
  int amount = 4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RANDOMGENERATOR:
    case PSEUDORANDOMGENERATOR:
      t10 = RandomGeneratorType();
                          t1 = new FFaplNodeChoice(t10, 0, amount);
      break;
    case Z:
    case GF:
                    t4 = new FFaplNodeSequence();
      t9 = ComplexAlgebraicType();
                          t4.addNode(t9);
                          t5 = new FFaplNodeListOpt();
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SQUARED_BRACE_LEFT:
          ;
          break;
        default:
          jj_la1[47] = jj_gen;
          break label_14;
        }
                              t6 = new FFaplNodeSequence();
        t0 = jj_consume_token(SQUARED_BRACE_LEFT);
                                  t6.addNode(new FFaplNodeToken(t0));
        t0 = jj_consume_token(SQUARED_BRACE_RIGHT);
                                  t6.addNode(new FFaplNodeToken(t0));
                                  t5.addNode(t6);
      }
                    t4.addNode(t5);
                    t1 = new FFaplNodeChoice(t4, 1, amount);
      break;
    case INTEGER:
    case BOOLEAN:
    case TSTRING:
                    t4 = new FFaplNodeSequence();
      t2 = PrimitiveType();
                          t4.addNode(t2);
                          t5 = new FFaplNodeListOpt();
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SQUARED_BRACE_LEFT:
          ;
          break;
        default:
          jj_la1[48] = jj_gen;
          break label_15;
        }
                              t6 = new FFaplNodeSequence();
        t0 = jj_consume_token(SQUARED_BRACE_LEFT);
                                  t6.addNode(new FFaplNodeToken(t0));
        t0 = jj_consume_token(SQUARED_BRACE_RIGHT);
                                  t6.addNode(new FFaplNodeToken(t0));
                                  t5.addNode(t6);
      }
                    t4.addNode(t5);
                    t1 = new FFaplNodeChoice(t4, 2, amount);
      break;
    case PRIME:
    case POLYNOMIAL:
                    t4 = new FFaplNodeSequence();
      t8 = AlgebraicType();
                          t4.addNode(t8);
                          t5 = new FFaplNodeListOpt();
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SQUARED_BRACE_LEFT:
          ;
          break;
        default:
          jj_la1[49] = jj_gen;
          break label_16;
        }
                              t6 = new FFaplNodeSequence();
        t0 = jj_consume_token(SQUARED_BRACE_LEFT);
                                  t6.addNode(new FFaplNodeToken(t0));
        t0 = jj_consume_token(SQUARED_BRACE_RIGHT);
                                  t6.addNode(new FFaplNodeToken(t0));
                                  t5.addNode(t6);
      }
                    t4.addNode(t5);
                    t1 = new FFaplNodeChoice(t4, 3, amount);
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return new ASTParamType(FFT_PARAMTYPE, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTDecl Decl() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t3, t5, t7;
  FFaplNodeListOpt t4;
  ASTDeclType t6;
  FFaplNodeSequence t8;
    //t1 = < DECLARE >
            //  {
            //    t2 = null;// new FFaplNodeToken(t1);
            //  }
      t1 = jj_consume_token(IDENT);
            t3 = new FFaplNodeToken(t1);
            t4 = new FFaplNodeListOpt();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_17;
      }
              t8 = new FFaplNodeSequence();
      t1 = jj_consume_token(COMMA);
              t8.addNode(new FFaplNodeToken(t1));
      t1 = jj_consume_token(IDENT);
              t8.addNode(new FFaplNodeToken(t1));
              t4.addNode(t8);
    }
    t1 = jj_consume_token(COLON);
            t5 = new FFaplNodeToken(t1);
    t6 = DeclType();
    t1 = jj_consume_token(SEMICOLON);
            t7 = new FFaplNodeToken(t1);
   {if (true) return new ASTDecl(FFT_DECL, t3, t4, t5, t6, t7);}
    throw new Error("Missing return statement in function");
  }

  final public ASTConstDecl ConstDecl() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t3, t4, t6, t8;
  ASTExpr t7;
  ASTConstType t5;
    t1 = jj_consume_token(CONST);
          t2 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(IDENT);
          t3 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(COLON);
          t4 = new FFaplNodeToken(t1);
    t5 = ConstType();
    t1 = jj_consume_token(ASSIGN);
          t6 = new FFaplNodeToken(t1);
    t7 = Expr();
    t1 = jj_consume_token(SEMICOLON);
          t8 = new FFaplNodeToken(t1);
    {if (true) return new ASTConstDecl(FFT_CONSTDECL, t2, t3, t4, t5, t6, t7, t8);}
    throw new Error("Missing return statement in function");
  }

  final public ASTIdTerm IdTerm() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2;
  FFaplNodeOpt t3;
  FFaplNodeSequence t4;
  ASTPrimaryExpr t5;
    t1 = jj_consume_token(IDENT);
               t2 = new FFaplNodeToken(t1);
               t3 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POWER:
                  t4 = new FFaplNodeSequence();
      t1 = jj_consume_token(POWER);
                  t4.addNode(new FFaplNodeToken(t1));
      t5 = PrimaryExpr();
                  t4.addNode(t5);
                  t3.addNode(t4);
      break;
    default:
      jj_la1[52] = jj_gen;
      ;
    }
       {if (true) return new ASTIdTerm(FFT_IDTERM, t2, t3);}
    throw new Error("Missing return statement in function");
  }

  final public ASTTerm Term() throws ParseException, FFaplException {
  FFaplNodeChoice t1;
  ASTPowExpr t2;
  ASTIdTerm t3;
  FFaplNodeSequence t4;
  FFaplNodeOpt t5;
  Token t6;
  int amount = 2;
    if (jj_2_8(2)) {
                          t4 = new FFaplNodeSequence();
                          t5 = new FFaplNodeOpt();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        t6 = jj_consume_token(MINUS);
                          t5.addNode(new FFaplNodeToken(t6));
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
                  t4.addNode(t5);
      t3 = IdTerm();
                             t4.addNode(t3);
                                 t1 = new FFaplNodeChoice(t4, 1, amount);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
      case PLUS:
      case MINUS:
      case HASH_KEY:
      case SQUARED_BRACE_LEFT:
      case CURLY_BRACE_LEFT:
      case BRACE_LEFT:
      case TRUE:
      case FALSE:
      case RANDOM:
      case IDENT:
      case NUMBER:
      case STRING:
                          t4 = new FFaplNodeSequence();
        t2 = PowExpr();
                  t4.addNode(t2);
                  t5 = new FFaplNodeOpt();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          t3 = IdTerm();
                          t5.addNode(t3);
          break;
        default:
          jj_la1[54] = jj_gen;
          ;
        }
                  t4.addNode(t5);
                  t1 = new FFaplNodeChoice(t4, 0, amount);
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new ASTTerm(FFT_TERM, t1);}
    throw new Error("Missing return statement in function");
  }

  final public ASTPolynomial Polynomial() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t5;
  ASTTerm t3, t7;
  FFaplNodeListOpt t4;
  ASTAddOp t6;
  FFaplNodeSequence t8;
    t1 = jj_consume_token(SQUARED_BRACE_LEFT);
          t2 = new FFaplNodeToken(t1);
    t3 = Term();
          t4 = new FFaplNodeListOpt();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_18;
      }
          t8 = new FFaplNodeSequence();
      t6 = AddOp();
          t8.addNode(t6);
      t7 = Term();
          t8.addNode(t7);
          t4.addNode(t8);
    }
    t1 = jj_consume_token(SQUARED_BRACE_RIGHT);
                  t5 = new FFaplNodeToken(t1);
    {if (true) return new ASTPolynomial(FFT_POLYNOMIAL, t2, t3, t4, t5);}
    throw new Error("Missing return statement in function");
  }

  final public ASTGF GF() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t3, t5, t7;
  ASTExpr t4, t6;
    t1 = jj_consume_token(GF);
          t2 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(BRACE_LEFT);
          t3 = new FFaplNodeToken(t1);
    t4 = Expr();
    t1 = jj_consume_token(COMMA);
          t5 = new FFaplNodeToken(t1);
    t6 = Expr();
    t1 = jj_consume_token(BRACE_RIGHT);
          t7 = new FFaplNodeToken(t1);
    {if (true) return new ASTGF(FFT_GF, t2, t3, t4, t5, t6, t7);}
    throw new Error("Missing return statement in function");
  }

  final public ASTRecord Record() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t4;
  FFaplNodeListOpt t3;
  ASTDecl t5;
    t1 = jj_consume_token(RECORD);
          t2 = new FFaplNodeToken(t1);
          t3 = new FFaplNodeListOpt();
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        ;
        break;
      default:
        jj_la1[57] = jj_gen;
        break label_19;
      }
      //Optional List
              t5 = Decl();
                      t3.addNode(t5);
    }
    t1 = jj_consume_token(ENDRECORD);
          t4 = new FFaplNodeToken(t1);
    {if (true) return new ASTRecord(FFT_RECORD, t2, t3, t4);}
    throw new Error("Missing return statement in function");
  }

  final public ASTPsRandomGenerator PsRandomGenerator() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t3, t5, t7;
  ASTExpr t4, t6;
    t1 = jj_consume_token(PSEUDORANDOMGENERATOR);
            t2 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(BRACE_LEFT);
            t3 = new FFaplNodeToken(t1);
    t4 = Expr();
    t1 = jj_consume_token(COMMA);
            t5 = new FFaplNodeToken(t1);
    t6 = Expr();
    t1 = jj_consume_token(BRACE_RIGHT);
            t7 = new FFaplNodeToken(t1);
    {if (true) return new ASTPsRandomGenerator(FFT_PSRANDOMGENERATOR, t2, t3, t4, t5, t6, t7);}
    throw new Error("Missing return statement in function");
  }

  final public ASTFormalParam FormalParam() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t4;
  FFaplNodeListOpt t3;
  ASTParamType t5;
  FFaplNodeSequence t6;
    t1 = jj_consume_token(IDENT);
            t2 = new FFaplNodeToken(t1);
            t3 = new FFaplNodeListOpt();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[58] = jj_gen;
        break label_20;
      }
          t6 = new FFaplNodeSequence();
      t1 = jj_consume_token(COMMA);
                t6.addNode(new FFaplNodeToken(t1));
      t1 = jj_consume_token(IDENT);
                t6.addNode(new FFaplNodeToken(t1));
                t3.addNode(t6);
    }
    t1 = jj_consume_token(COLON);
            t4 = new FFaplNodeToken(t1);
    t5 = ParamType();
     {if (true) return new ASTFormalParam(FFT_FORMALPARAM, t2, t3, t4, t5);}
    throw new Error("Missing return statement in function");
  }

  final public ASTFormalParamList FormalParamList() throws ParseException, FFaplException {
  ASTFormalParam t1, t5;
  FFaplNodeListOpt t2;
  FFaplNodeSequence t3;
  Token t4;
    t1 = FormalParam();
            t2 = new FFaplNodeListOpt();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        ;
        break;
      default:
        jj_la1[59] = jj_gen;
        break label_21;
      }
              t3 = new FFaplNodeSequence();
      t4 = jj_consume_token(SEMICOLON);
          t3.addNode(new FFaplNodeToken(t4));
      t5 = FormalParam();
              t3.addNode(t5);
              t2.addNode(t3);
    }
     {if (true) return new ASTFormalParamList(FFT_FORMALPARAMLIST, t1, t2);}
    throw new Error("Missing return statement in function");
  }

  final public ASTProgram Program() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t3, t4, t8, t9;
  FFaplNodeListOpt t5, t6, t14;
  ASTStatementList t7;
  FFaplNodeChoice t10;
  ASTProc t11;
  ASTFunc t12;
  ASTDecl t13;
  ASTConstDecl t15;
  int amount = 2;
    t1 = jj_consume_token(PROGRAM);
            t2 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(IDENT);
            _programName = t1.image;
            t3 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(CURLY_BRACE_LEFT);
            t4 = new FFaplNodeToken(t1);
            t14 = new FFaplNodeListOpt();
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
        ;
        break;
      default:
        jj_la1[60] = jj_gen;
        break label_22;
      }
      //Optional List
           t15 = ConstDecl();
              t14.addNode(t15);
    }
          t5 = new FFaplNodeListOpt();
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROCEDURE:
      case FUNCTION:
        ;
        break;
      default:
        jj_la1[61] = jj_gen;
        break label_23;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROCEDURE:
        t11 = Proc();
                          t10 = new FFaplNodeChoice(t11, 0, amount);
        break;
      case FUNCTION:
        t12 = Func();
                          t10 = new FFaplNodeChoice(t12, 1, amount);
        break;
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
              t5.addNode(t10);
    }
                  t6 = new FFaplNodeListOpt();
    label_24:
    while (true) {
      if (jj_2_9(2)) {
        ;
      } else {
        break label_24;
      }
      t13 = Decl();
          t6.addNode(t13);
    }
    t7 = StatementList();
    t1 = jj_consume_token(CURLY_BRACE_RIGHT);
            t8 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(0);
            t9 = new FFaplNodeToken(t1);
    {if (true) return new ASTProgram(FFT_PROGRAM, t2, t3, t4, t14, t5, t6, t7, t8, t9);}
    throw new Error("Missing return statement in function");
  }

  final public ASTProc Proc() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t3, t4, t6;
  FFaplNodeOpt t5;
  ASTBlock t7;
  ASTFormalParamList t8;
    t1 = jj_consume_token(PROCEDURE);
          t2 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(IDENT);
          t3 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(BRACE_LEFT);
          t4 = new FFaplNodeToken(t1);
          t5 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      t8 = FormalParamList();
                  t5.addNode(t8);
      break;
    default:
      jj_la1[63] = jj_gen;
      ;
    }
    t1 = jj_consume_token(BRACE_RIGHT);
          t6 = new FFaplNodeToken(t1);
    t7 = Block();
    {if (true) return new ASTProc(FFT_PROC, t2, t3, t4, t5, t6, t7);}
    throw new Error("Missing return statement in function");
  }

  final public ASTFunc Func() throws ParseException, FFaplException {
  Token t1;
  FFaplNodeToken t2, t3, t4, t6, t7;
  FFaplNodeOpt t5;
  ASTParamType t8;
  ASTFuncBlock t9;
  ASTFormalParamList t10;
    t1 = jj_consume_token(FUNCTION);
          t2 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(IDENT);
          t3 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(BRACE_LEFT);
          t4 = new FFaplNodeToken(t1);
          t5 = new FFaplNodeOpt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      t10 = FormalParamList();
                  t5.addNode(t10);
      break;
    default:
      jj_la1[64] = jj_gen;
      ;
    }
    t1 = jj_consume_token(BRACE_RIGHT);
          t6 = new FFaplNodeToken(t1);
    t1 = jj_consume_token(COLON);
          t7 = new FFaplNodeToken(t1);
    t8 = ParamType();
    t9 = FuncBlock();
    {if (true) return new ASTFunc(FFT_FUNC, t2, t3, t4, t5, t6, t7, t8, t9);}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_3R_52() {
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_scan_token(IDENT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_scan_token(SQUARED_BRACE_LEFT)) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) return true;
    }
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(SQUARED_BRACE_LEFT)) return true;
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_scan_token(BRACE_LEFT)) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_scan_token(RANDOM)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_26()) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) return true;
    }
    return false;
  }

  private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) jj_scanpos = xsp;
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_scan_token(SQUARED_BRACE_LEFT)) return true;
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3_1()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_29()) jj_scanpos = xsp;
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_scan_token(IDENT)) return true;
    if (jj_scan_token(BRACE_LEFT)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_scan_token(POWER)) return true;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_scan_token(HASH_KEY)) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_scan_token(IDENT)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_34()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_scan_token(CURLY_BRACE_LEFT)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public FFaplTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[65];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x3c0,0xc00,0x6000,0x58000,0x40000000,0x1000000,0x40000000,0x100000,0x4100000,0x4100000,0x4100000,0x4100000,0x4100000,0x1100000,0x480000,0x7000,0x7000,0x80000000,0x58000,0x3c0,0xc00,0x0,0x100000,0x0,0x0,0x0,0x1587000,0x20000000,0x1587000,0x4100000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x100000,0x100000,0x0,0x100000,0x100000,0x100000,0x0,0x20000000,0x80000000,0x4000,0x0,0x1587000,0x6000,0x0,0x20000000,0x10000000,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb000,0x0,0x0,0x0,0x0,0x0,0xb000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x80004,0x410000,0x2,0xb200,0x0,0xb200,0x0,0x400,0x4000,0x40000,0x20000d00,0x20000d00,0x20000000,0xd00,0x98,0x60,0x80004,0x410000,0x800fc,0x800fc,0x0,0x0,0x0,0x5900fc,0x0,0x0,0x0,0x4900fc,0x0,0x0,0x0,0x0,0xb000,0x0,0x0,0x0,0x0,0x10000000,0x6000000,0x6000000,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x0,0x0,0x6,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x7,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x7,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x1,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[9];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public FFapl(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public FFapl(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new FFaplTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public FFapl(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new FFaplTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public FFapl(FFaplTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(FFaplTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[74];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 65; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 74; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 9; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }
  

}
