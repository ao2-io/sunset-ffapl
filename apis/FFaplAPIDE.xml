<?xml version="1.0" encoding="UTF-8"?>
<FFapl>
	<type>
		<name>Integer</name>
		<description>Repräsentiert einen Integer-Wert.</description>
		<regex>Integer</regex>
	</type>
	<type>
		<name>Z(p)</name>
		<description>Repräsentiert eine Restklasse modulo {i}p{/i}.</description>
		<regex>Z</regex>
	</type>
	<type>
		<name>String</name>
		<description>Repräsentiert eine Zeichenkette.</description>
		<regex>String</regex>
	</type>
	<type>
		<name>Z(p)[x]</name>
		<description>Repräsentiert einen Polynomring modulo {i}p{/i}.</description>
		<regex>Z</regex>
	</type>
	<type>
		<name>GF(p, g)</name>
		<description>Repräsentiert ein Galois Feld mit Charakteristik {i}p{/i} und irreduziblen Polynom {i}g{/i}.</description>
		<regex>GF</regex>
	</type>
	<type>
		<name>PseudoRandomGenerator(seed, max)</name>
		<description>Repräsentiert einen Pseudozufahlszahlen-Generator mit Startwert {i}seed{/i}.{br}Generiert Pseudozufallszahlen zwischen 0 und {i}max{/i}.</description>
		<regex>PseudoRandomGenerator</regex>
	</type>
	<type>
		<name>RandomGenerator(max)</name>
		<description>Repräsentiert einen Zufallszahlen-Generator.{br}Generiert Zufallszahlen zwischen 0 und {i}max{/i}.</description>
		<regex>RandomGenerator</regex>
	</type>	
	<type>
		<name>RandomGenerator(min : max)</name>
		<description>Repräsentiert einen Zufallszahlen-Generator.{br}Generiert Zufallszahlen zwischen {i}min{/i} und {i}max{/i}.</description>
		<regex>RandomGenerator</regex>
	</type>


<function>
	<name>max</name>
		<parameters>
			<parameter>
			    <name>a</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
			<parameter>
			    <name>b</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Retourniert das Maximum von {i}a{/i} und {i}b{/i}.</description>
	<regex>max</regex>
	<return>Integer</return>
</function>

<function>
	<name>min</name>
		<parameters>
			<parameter>
			    <name>a</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
			<parameter>
			    <name>b</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Retourniert das Minimum von {i}a{/i} und {i}b{/i}.</description>
	<regex>min</regex>
	<return>Integer</return>
</function>

<function>
	<name>getNextPrime</name>
		<parameters>
			<parameter>
			    <name>val</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Retourniert die nächste Primzahl nach dem Wert {i}val{/i}.</description>
	<regex>getNextPrime</regex>
	<return>Integer</return>
</function>

<function>
	<name>irreduciblePolynomial</name>
		<parameters>
			<parameter>
			    <name>n</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
			<parameter>
			    <name>p</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Generiert ein irreduzibles Polynom vom Grad {i}n{/i} modulo {i}p{/i}.</description>
	<regex>irreduciblePolynomial</regex>
	<return>Polynomial</return>
</function>

<function>
	<name>randomPolynomial</name>
		<parameters>
			<parameter>
			    <name>n</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
			<parameter>
			    <name>p</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Generiert ein zufälliges Polynom vom Grad {i}n{/i} modulo {i}p{/i}.</description>
	<regex>randomPolynomial</regex>
	<return>Polynomial</return>
</function>

<function>
	<name>factorInteger</name>
		<parameters>
			<parameter>
			    <name>n</name>
				<type>Integer</type>
			</parameter>
		</parameters>
	<description>Faktorisiert eine Zahl {i}n{/i}. Wechselt zwischen Pollard's rho, Pollard's p-1 und simpler Iteration.</description>
	<regex>factorInteger</regex>
	<return>Integer[][]</return>
</function>

<function>
	<name>factorSquareFree</name>
		<parameters>
			<parameter>
			    <name>f</name>
				<type>GF()</type>
			</parameter>
		</parameters>
	<description>Retouniert die quadratfreie Faktorisierung von {i}f{/i} in {i}GF{/i}. </description>
	<regex>factorSquareFree</regex>
	<return>Polynomial[][]</return>
</function>

<function>
	<name>factor</name>
		<parameters>
			<parameter>
			    <name>f</name>
				<type>GF()</type>
			</parameter>
		</parameters>
	<description>Retouniert die Faktorisierung von {i}f{/i} in {i}GF{/i}. </description>
	<regex>factor</regex>
	<return>Polynomial[][]</return>
</function>

<function>
	<name>evaluatePolynomial</name>
		<parameters>
			<parameter>
			    <name>f</name>
				<type>GF()</type>
				<type>Polynomial</type>
				<type>Z(p)[x]</type>
			</parameter>
			<parameter>
			    <name>val</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Berechnet den Wert von {i}f{/i}, mit {i}x{/i} := {i}val{/i}. </description>
	<regex>evaluatePolynomial</regex>
	<return>Integer</return>
</function>

<function>
	<name>gcd</name>
		<parameters>
			<parameter>
			    <name>a</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
			<parameter>
			    <name>b</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Retourniert den größten gemeinsamen Teiler {i}a{/i} und {i}b{/i}.</description>
	<regex>gcd</regex>
	<return>Integer</return>
</function>

<function>
	<name>lcm</name>
		<parameters>
			<parameter>
			    <name>a</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
			<parameter>
			    <name>b</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Retourniert das kleinste gemeinsame Vielfache von {i}a{/i} und {i}b{/i}.</description>
	<regex>lcm</regex>
	<return>Integer</return>
</function>

<function>
	<name>gcd</name>
		<parameters>
			<parameter>
			    <name>a</name>
				<type>Z()[x]</type>
			</parameter>
			<parameter>
			    <name>b</name>
				<type>Z()[x]</type>
			</parameter>
		</parameters>
	<description>Retourniert den größten gemeinsamen Teiler {i}a{/i} und {i}b{/i} in {i}Z()[x]{/i}.</description>
	<regex>gcd</regex>
	<return>Integer</return>
</function>

<function>
	<name>eea</name>
		<parameters>
			<parameter>
			    <name>a</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
			<parameter>
			    <name>b</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Retourniert das Array {{i}d{/i},{i}s{/i},{i}t{/i}} wobei  {i}s{/i}*{i}a{/i} + {i}t{/i}*{i}b{/i} = {i}gcd{/i}({i}a{/i},{i}b{/i}) = {i}d{/i} ist.</description>
	<regex>eea</regex>
	<return>Integer[]</return>
</function>

<function>
	<name>eea</name>
		<parameters>
			<parameter>
			    <name>g</name>
				<type>Z()[x]</type>
			</parameter>
			<parameter>
			    <name>h</name>
				<type>Z()[x]</type>
			</parameter>
		</parameters>
	<description>Retourniert das Array {{i}d{/i},{i}s{/i},{i}t{/i}} wobei  {i}s{/i}*{i}g{/i} + {i}t{/i}*{i}h{/i} = {i}gcd{/i}({i}g{/i},{i}h{/i}) = {i}d{/i} in {i}Z()[x]{/i} ist.</description>
	<regex>eea</regex>
	<return>Z()[x][]</return>
</function>

<function>
	<name>isPrime</name>
		<parameters>
			<parameter>
			    <name>val</name>
				<type>Integer</type>
			</parameter>
		</parameters>
	<description>Retourniert {i}true{/i} falls {i}val{/i} prim ist, {i}false{/i} andernfalls.</description>
	<regex>isPrime</regex>
	<return>Boolean</return>
</function>

<function>
	<name>isIrreducible</name>
		<parameters>
			<parameter>
			    <name>val</name>
				<type>Z()[x]</type>
			</parameter>
		</parameters>
	<description>Retourniert {b}true{/b} falls {i}val{/i} irreduzibel ist in {i}Z()[x]{/i}, {b}false{/b} andernfalls.</description>
	<regex>isIrreducible</regex>
	<return>Boolean</return>
</function>

<function>
	<name>isIrreducible</name>
		<parameters>
			<parameter>
			    <name>ply</name>
				<type>Polynomial</type>
			</parameter>
			<parameter>
			    <name>p</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Retourniert {b}true{/b} falls {i}ply{/i} irreduzibel ist in {i}Z(p)[x]{/i}, {b}false{/b} andernfalls.</description>
	<regex>isIrreducible</regex>
	<return>Boolean</return>
</function>
<function>
	<name>isPrimitive</name>
		<parameters>
			<parameter>
			    <name>ply</name>
				<type>Polynomial</type>
			</parameter>
			<parameter>
			    <name>p</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
			<parameter>
			    <name>primeFactors</name>
				<type>Prime[]</type>
			</parameter>
		</parameters>
	<description>Retourniert {b}true{/b} falls {i}ply{/i} primitiv ist in {i}Z(p)[x]{/i}, {b}false{/b} andernfalls.
	{br}{i}primeFactors{/i} := Primfaktoren von {i}p^(Grad von ply) - 1{/i}.</description>
	<regex>isPrimitive</regex>
	<return>Boolean</return>
</function>

<function>
	<name>isPrimitive</name>
		<parameters>
			<parameter>
			    <name>ply</name>
				<type>Polynomial</type>
			</parameter>
			<parameter>
			    <name>p</name>
				<type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Retourniert {b}true{/b} falls {i}ply{/i} primitiv ist in {i}Z(p)[x]{/i}, {b}false{/b} andernfalls.
	{br}{i}p^(Grad von ply) - 1{/i} wird in Primfaktoren zerlegt (kann unter Umständen Zeit beanspruchen).</description>
	<regex>isPrimitive</regex>
	<return>Boolean</return>
</function>

<function>
	<name>isPrimitive</name>
		<parameters>
			<parameter>
			    <name>ply</name>
				<type>Z(p)[x]</type>
			</parameter>
		</parameters>
	<description>Retourniert {b}true{/b} falls {i}ply{/i} primitive ist in {i}Z(p)[x]{/i}, {b}false{/b} andernfalls.
	{br}{i}primeFactors{/i} := Primfaktoren von {i}p^(Grad von ply) - 1{/i}.</description>
	<regex>isPrimitive</regex>
	<return>Boolean</return>
</function>


<function>
	<name>getIrreduciblePolynomial</name>
		<parameters>
			<parameter>
			    <name>val</name>
				<type>GF()</type>
			</parameter>
		</parameters>
	<description>Retourniert das irreduzible Polynom von {i}GF(){/i} des Wertes {i}val{/i}.</description>
	<regex>getIrreduciblePolynomial</regex>
	<return>Polynomial</return>
</function>

<function>
	<name>getCharacteristic</name>
		<parameters>
			<parameter>
			    <name>val</name>
				<type>GF()</type>
				<type>Z()</type>
				<type>Z()[x]</type>
			</parameter>
		</parameters>
	<description>Retourniert die Charakteristik von [{i}GF(){/i} | {i}Z(){/i} | {i}Z()[x]{/i}] des Wertes {i}val{/i}.</description>
	<regex>getCharacteristic</regex>
	<return>Integer</return>
</function>

<function>
	<name>leadingCoefficient</name>
		<parameters>
			<parameter>
			    <name>ply</name>
			    <type>Polynomial</type>
				<type>Z()[x]</type>
				<type>GF()</type>
			</parameter>
		</parameters>
	<description>Retouniert den Leitkoeffizienten von {i}ply{/i}.</description>
	<regex>leadingCoefficient</regex>
	<return>Integer</return>
</function>

<function>
	<name>convertToInteger</name>
		<parameters>
			<parameter>
			    <name>val</name>
				<type>Z(p)</type>
			</parameter>
		</parameters>
	<description>Konvertiert Wert {i}val{/i} in {i}Z(p){/i} zu {i}Integer{/i}.</description>
	<regex>convertToInteger</regex>
	<return>Integer</return>
</function>

<function>
	<name>degree</name>
		<parameters>
			<parameter>
			    <name>ply</name>
			    <type>Polynomial</type>
				<type>Z()[x]</type>
				<type>GF()</type>
			</parameter>
		</parameters>
	<description>Retouniert den Grad von {i}ply{/i}.</description>
	<regex>degree</regex>
	<return>Integer</return>
</function>

<function>
	<name>coefficientAt</name>
		<parameters>
			<parameter>
			    <name>ply</name>
			    <type>Polynomial</type>
				<type>Z()[x]</type>
				<type>GF()</type>
			</parameter>
			<parameter>
			    <name>e</name>
			    <type>Integer</type>
				<type>Prime</type>
			</parameter>
		</parameters>
	<description>Retouniert den Koeffizienten von {i}x^e{/i} in {i}ply{/i}.</description>
	<regex>coefficientAt</regex>
	<return>Integer</return>
</function>

<function>
	<name>TLPairing</name>
		<parameters>
			<parameter>
			    <name>P</name>
			    <type>EC</type>
			</parameter>
			<parameter>
			    <name>Q</name>
			    <type>EC</type>
			</parameter>
		</parameters>
	<description>Berechnet das Tate-Lichtenbaum Pairing der Punkte {P} und {Q}.</description>
	<regex>tlPairing</regex>
	<return>GF</return>
</function>

<procedure>
	<name>print</name>
	<parameters>
			<parameter>
			    <name>val</name>
				<type>Integer</type>
				<type>String</type>
				<type>Prime</type>
				<type>Random</type>
				<type>Z()</type>
				<type>Z()[x]</type>
				<type>GF</type>
				<type>PseudoRandomGenerator</type>
				<type>RandomGenerator</type>
			</parameter>
	</parameters>
	<regex>print</regex>
	<description>Gibt {i}val{/i} aus.</description>
</procedure>
<procedure>
	<name>println</name>
	<parameters>
			<parameter>
			    <name>val</name>
				<type>Integer</type>
				<type>String</type>
				<type>Prime</type>
				<type>Random</type>
				<type>Z()</type>
				<type>Z()[x]</type>
				<type>GF</type>
				<type>PseudoRandomGenerator</type>
				<type>RandomGenerator</type>
			</parameter>
	</parameters>
	<regex>println</regex>
	<description>Gibt {i}val{/i} und neue Zeile aus.</description>
</procedure>

<samples>
	<procedure>
		<name>proc</name>
		<parameters>
				<parameter>
				    <name>val</name>
					<type>Integer</type>
				</parameter>
		</parameters>
		<code>
	procedure proc(val : Integer) {
		//Hier Code einfügen
	}</code>
		<regex>proc</regex>
		<description>Beispiel einer Prozedur mit einem Parameter {i}val{/i}.</description>
	</procedure>
	
	<function>
		<name>func</name>
		<parameters>
				<parameter>
				    <name>val</name>
					<type>Integer</type>
				</parameter>
		</parameters>
		<regex>func</regex>
		<code>
	function func(val : Integer) : Integer{
		//Hier Code einfügen
		return //Hier Rückgabewert angeben
	}</code>
		<return>Integer</return>
		<description>Beispiel einer Funktion mit einem Parameter {i}val{/i} und einem Rückgabetyp.</description>
	</function>
	<function>
		<name>faculty</name>
		<parameters>
				<parameter>
				    <name>val</name>
					<type>Integer</type>
				</parameter>
		</parameters>
		<regex>faculty</regex>
		<code>
	function faculty(val : Integer) : Integer{
		f : Integer;
		f := 1;
		for i = 1 to val{
			f:= f * i;
		}
		return f;
	}</code>
		<return>Integer</return>
		<description>Berechnet die Fakultät von {i}val{/i}.</description>
	</function>
	<function>
		<name>facultyRecursion</name>
		<parameters>
				<parameter>
				    <name>val</name>
					<type>Integer</type>
				</parameter>
		</parameters>
		<regex>faculty</regex>
		<code>
	function facultyRecursion(val : Integer) : Integer{
		f : Integer;
		if(val == 1){
		    f := 1;
		}else{
		    f := val * facultyRecursion(val - 1);
		}
		return f;
	}</code>
		<return>Integer</return>
		<description>Berechnet die Fakultät von {i}val{/i} rekursiv.</description>
	</function>
	
	<function>
		<name>isIrreducibleQ</name>
		<parameters>
				<parameter>
				    <name>f</name>
					<type>Polynomial</type>
				</parameter>
				<parameter>
				    <name>p</name>
					<type>Prime</type>
				</parameter>
		</parameters>
		<regex>isIrreducibleQ</regex>
		<code>
	/** 
	* Testet Polynom auf Irreduzibilität
	* Algorithmus nach Handbook of Applied Cryptography 
	* Algorithmus 4.69
	*/
	function isIrreducibleQ(f : Polynomial; p : Prime) : Boolean{
		result : Boolean;
		u, d, ff : Z(p)[x];
    		lc: Z(p);
		m: Integer;
		ff := f;
	
		if(leadingCoefficient(ff) > 1){
			//nicht normiert
    	    		lc := leadingCoefficient(ff);
    	    		ff := ff * lc^-1;
		}
		
		result := true;
    		m := degree(ff);
		u := [x]; // u(x) := x
	   	if(m != 1){
			for i = 1 to m/2 { // for i to m/2
				u := u^p MOD ff;  // u(x) := u(x)^p mod f(x)
				d := gcd(ff, u - [x]); //d(x) := gcd(f(x), u(x) - x)
           			if(degree(d) > 0){ // Wenn d(x) != 1 nicht irreduzibel
					result := false; 
					break;
				}
			}
		}
		return result;
	}
	</code>
		<return>Boolean</return>
		<description>Testet Polynom {i}f{/i} auf Irreduzibilität in {i}Z(p)[x]{/i}.</description>
	</function>
	
	<function>
		<name>isPrimitiveQ</name>
		<parameters>
				<parameter>
				    <name>f</name>
					<type>Polynomial</type>
				</parameter>
				<parameter>
				    <name>p</name>
					<type>Prime</type>
				</parameter>
		</parameters>
		<regex>isPrimitiveQ</regex>
		<code>
	/** 
	* Testet ob Polynom primitiv ist
	* Algorithmus nach Handbook of Applied Cryptography 
	* Algorithmus 4.77
	*/
	function isPrimitiveQ(f : Polynomial; p : Prime) : Boolean{
		result : Boolean;
		u, d, ff, lx : Z(p)[x];
    		lc: Z(p);
		m, pm, val: Integer;
    		primeFactors : Integer[][];
		ff := f;
	
		if(isIrreducibleQ(f, p)){
			m:= degree(f);
			pm := p^m - 1;
			
			if(leadingCoefficient(ff) > 1){
				//nicht normiert
        			lc := leadingCoefficient(ff);
        			ff := ff * lc^-1;
			}
			
			primeFactors := factorInteger(pm); //Primfaktoren von p^m - 1
            		result := true;
			for i = 0 to #primeFactors - 1{
				val := primeFactors[i][0]; 
				lx := [x]^(pm/val) MOD ff; //l(x) := x^((p^m - 1) / r_i) mod f(x)
				if(lx == 1){ // nicht primitiv
					result := false;
					break;
				}
			}
		}else{ // nicht irreduzibel daher auch nicht primtiv
			result := false;
		}
  		return result;
	}
	</code>
		<return>Boolean</return>
		<description>Testet Polynom {i}f{/i} primitiv ist in {i}Z(p)[x]{/i},{br}
		d.h. {i}x{/i} ist Generator der multiplikativen Gruppe von {i}GF(p, f){/i}.</description>
	</function>
	
</samples>

</FFapl>